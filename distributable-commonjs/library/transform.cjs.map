{"version":3,"sources":["../../source/library/transform.js"],"names":["Babel","DefaultBabel","ModuleBabel","ESLint","Lint","FilePath","__filename","format","Format","BaseFormat","Require","require","Transform","getASTFromContent","content","option","lexerOutput","path","parserOutput","loaderOutput","Lex","Parse","AST","getSourceFromContent","blockNode","BlockNode","blockSource","getSource","source","EachNode","__forEach","toString","AndAttributeNode","__addAndAttribute","AttributeNode","__getAttributeName","__getAttributeValue","__addAttribute","TagNode","__getNodeName","__getNodeProperty","__getChildNode","__createNode","Package","name","version","Path","relative","local","_getLocalFromSource","getFunctionSourceFromContent","map","join","getFunctionFromContent","formatSource","fn","eval","getASTFromPath","FileSystem","readFile","getSourceFromPath","getFunctionSourceFromPath","getFunctionFromPath","createModuleFromPath","sourcePath","targetPath","extname","writeFile","resolve","extension","toLowerCase","configuration","JSON5","parse","env","code","sourceOut","transformAsync","lint","result","lintText","pattern","messages","filter","message","ruleId","match","Is","not","null","exec","UnrecognizedMessageTransformError","reduce","accumulator","undefined","Object","keys"],"mappings":"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","sourcesContent":["import DefaultBabel, * as ModuleBabel from '@babel/core'\nimport ESLint from 'eslint'\nimport FileSystem from 'fs-extra'\nimport BaseFormat from 'prettier'\nimport Is from '@pwn/is'\nimport JSON5 from 'json5'\nimport Lex from 'pug-lexer'\nimport Link from 'pug-linker'\nimport Load from 'pug-load'\nimport Parse from 'pug-parser'\nimport Path from 'path'\n// import URL from 'url'\n\nimport AndAttributeNode from './node/and-attribute-node.js'\nimport AttributeNode from './node/attribute-node.js'\nimport BlockNode from './node/block-node.js'\nimport EachNode from './node/each-node.js'\nimport TagNode from './node/tag-node.js'\nimport { Package } from './package.js'\n\nimport { UnrecognizedMessageTransformError } from './error/unrecognized-message-transform-error.js'\n\nconst Babel = DefaultBabel || ModuleBabel\nconst { ESLint: Lint } = ESLint\nconst FilePath = __filePath\nconst { format: Format } = BaseFormat\nconst Require = __require\n\nclass Transform {\n  \n  static getASTFromContent(content, option = { 'path': '(anonymous)' }) {\n    // console.log('Transform.getASTFromContent(content, option) { ... }')\n\n    let lexerOutput = Lex(content, { 'filename': option.path })\n    let parserOutput = Parse(lexerOutput, { 'filename': option.path })\n    let loaderOutput = Load(parserOutput, { 'lex': Lex, 'parse': Parse })\n    let AST = Link(loaderOutput)\n\n    return AST\n\n  }\n\n  static async getSourceFromContent(content, option = { 'path': '(anonymous)' }) {\n    // console.log('Transform.getSourceFromContent(content, option) { ... }')\n\n    let AST = this.getASTFromContent(content, option)\n    let blockNode = new BlockNode(AST, option)\n    let blockSource = await blockNode.getSource()\n\n    let source =  ` function ${EachNode.__forEach.toString()}\n                    function ${AndAttributeNode.__addAndAttribute.toString()}\n                    function ${AttributeNode.__getAttributeName.toString()}\n                    function ${AttributeNode.__getAttributeValue.toString()}\n                    function ${AttributeNode.__addAttribute.toString()}\n                    function ${TagNode.__getNodeName.toString()}\n                    function ${TagNode.__getNodeProperty.toString()}\n                    function ${TagNode.__getChildNode.toString()}\n                    function ${TagNode.__createNode.toString()}\n                    function __getNode(__option = {}) { \n                      // Powered by ${Package.name} v${Package.version}\n                      // FilePath = '${Path.relative('', FilePath)}'\n                      const __node = []\n                      ${blockSource}\n                      return __node\n                    }`\n\n    let local = await this._getLocalFromSource(source)\n\n    return { source, local }\n\n  }\n\n  static async getFunctionSourceFromContent(content, option = { 'path': '(anonymous)' }) {\n    // console.log('Transform.getFunctionSourceFromContent(content, option) { ... }')\n\n    let { source, local } = await this.getSourceFromContent(content, option)\n\n    local = local\n      .map((local) => `const { ${local} } = __local`)\n      .join('\\n')\n\n    source =  ` function __getNode(__local = {}, __option = {}) {\n                  // Powered by ${Package.name} v${Package.version}\n                  // FilePath = '${Path.relative('', FilePath)}'\n                  ${local}\n                  ${source} \n                  return __getNode(__option) \n                }`\n\n    return source\n\n  }\n\n  static async getFunctionFromContent(content, option = { 'path': '(anonymous)' }) {\n    // console.log('Transform.getFunctionFromContent(content, option) { ... }')\n\n    let source = null\n    source = await this.getFunctionSourceFromContent(content, option)\n    source = await this.formatSource(source)\n\n    let fn = null\n    eval(`fn = ${source}`)\n\n    return fn\n\n  }\n\n  static async getASTFromPath(path) {\n    // console.log(`Transform.getASTFromPath('${Path.relative('', path)}') { ... }`)\n\n    let content = await FileSystem.readFile(path, { 'encoding': 'utf-8' })\n    let AST = this.getASTFromContent(content, { 'path': path })\n\n    return AST\n\n  }\n\n  static async getSourceFromPath(path) {\n    // console.log(`Transform.getSourceFromPath('${Path.relative('', path)}') { ... }`)\n\n    let content = await FileSystem.readFile(path, { 'encoding': 'utf-8' })\n    let source = await this.getSourceFromContent(content, { 'path': path })\n\n    return source\n\n  }\n\n  static async getFunctionSourceFromPath(path) {\n    // console.log('Transform.getFunctionSourceFromPath('${Path.relative('', path)}') { ... }`)\n\n    let content = await FileSystem.readFile(path, { 'encoding': 'utf-8' })\n    let source = await this.getFunctionSourceFromContent(content, { 'path': path })\n\n    return source\n\n  }\n\n  static async getFunctionFromPath(path) {\n    // console.log(`Transform.getFunctionFromPath('${Path.relative('', path)}') { ... }`)\n\n    let content = await FileSystem.readFile(path, { 'encoding': 'utf-8' })\n    let fn = await this.getFunctionFromContent(content, { 'path': path })\n\n    return fn\n\n  }\n\n  static async createModuleFromPath(sourcePath, targetPath = `${sourcePath}${Path.extname(FilePath)}`, option = { 'encoding': 'utf-8', 'flag': 'wx' }) {\n    // console.log(`Transform.createModuleFromPath('${Path.relative('', sourcePath)}') { ... }`)\n\n    let source = null\n    source = await this.getFunctionSourceFromPath(sourcePath)\n    source =  ` import CreateVirtualNode from 'virtual-dom/h.js'\n                import _ConvertToVirtualNode from 'html-to-vdom'\n                import VirtualNode from 'virtual-dom/vnode/vnode.js'\n                import VirtualText from 'virtual-dom/vnode/vtext.js'\n                const ConvertToVirtualNode = _ConvertToVirtualNode({ 'VNode': VirtualNode, 'VText': VirtualText })\n                ${source}\n                export default function(__local = {}, __option = { 'createNode': CreateVirtualNode, 'convertToNode': ConvertToVirtualNode }) { \n                  // Powered by ${Package.name} v${Package.version}\n                  // FilePath = '${Path.relative('', FilePath)}'\n                  return __getNode(__local, __option) \n                }`\n\n    source = await this.formatSource(source)\n\n    await FileSystem.writeFile(targetPath, source, option)\n\n    // return import(URL.pathToFileURL(targetPath))\n    // return import(targetPath)\n\n    // __transformPath does ...\n    //   URL.pathToFileURL if the environment is ESModule\n    //   require.resolve if the environment is CommonJS\n    return import(__transformPath(targetPath))\n\n  }\n\n  static async formatSource(source) {\n\n    let extension = null\n    extension = Path.extname(FilePath)\n    extension = extension.toLowerCase()\n\n    let configuration = null\n    configuration = JSON5.parse(await FileSystem.readFile(Require.resolve('./transform.babelrc.json')), { 'encoding': 'utf-8' })\n    configuration = configuration.env[extension === '.cjs' ? 'commonjs' : 'esmodule']\n    \n    let { code: sourceOut } = await Babel.transformAsync(source, configuration)\n\n    sourceOut = Format(sourceOut, {\n      'arrowParens': 'always',\n      'bracketSpacing': true,\n      'parser': 'babel',\n      'quoteProps': 'consistent',\n      'semi': false,\n      'singleQuote': true,\n      'tabWidth': 2,\n      'trailingComma': 'none'\n    })\n\n    return sourceOut\n\n  }\n\n  static async _getLocalFromSource(source) {\n\n    let configuration = JSON5.parse(await FileSystem.readFile(Require.resolve('./transform.eslintrc.json')), { 'encoding': 'utf-8' })\n    let lint = new Lint({ 'baseConfig': configuration })\n\n    let result = await lint.lintText(source)\n    let pattern = /^'(.*)' is not defined.$/i\n\n    let local = null\n    local = result[0].messages\n      .filter((message) => message.ruleId === 'no-undef')\n      .map((message) => message.message)\n      .map((message) => {\n\n        let match = null\n\n        if (Is.not.null(match = pattern.exec(message))) {\n          let [ , local ] = match\n          return local\n        } else {\n          throw new UnrecognizedMessageTransformError(message)\n        }\n\n      })\n      .reduce((accumulator, local) => {\n        accumulator[local] = undefined\n        return accumulator\n      }, {})\n\n    local = Object.keys(local)\n\n    return local\n\n  }\n\n}\n\nexport { Transform }"],"file":"transform.cjs"}